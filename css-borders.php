<?php include ("header.php") ?>

    <div class="container header">
        <div class="row">
            <h1>CSS Рамки</h1>
        </div>
    </div>

<div class="container body">
    <div class="row">
        <h1>
            Внешняя рамка
        </h1>
        <p>
            Полезное, но редко используемое свойство — внешняя рамка или outline.
            <br><br>
            Синтаксис outline схож с border. Но внешней рамке нельзя задать параметры отдельных сторон. Пример:
        </p>

            <pre>
                <code class="css">
                    /* сплошная чёрная рамка толщиной 10px */
                    outline: 10px solid black;
                    /* Это сокращённый синтаксис свойства outline. Есть и отдельные свойства: */
                    outline-width: 10px;  /* толщина */
                    outline-style: solid; /* стиль */
                    outline-color: black; /* цвет */
                </code>
            </pre>
        <p>
            Внешняя рамка всегда отображается снаружи элемента, не влияет на его размер и не занимает места, то есть отображается над другими элементами.
            <br><br>
            C помощью свойства outline-offset можно изменять расположение рамки. Положительное значение отодвигает рамку
            от внешнего края элемента, а отрицательное «втягивает» внутрь.
            <br><br>
            У outline-style те же значения, что и у border-style. Кстати, есть интересные типы рамок ridge и groove,
            они создают объёмные рамки.
        </p>
    </div>

    <div class="row">
        <h1>
            Скругление углов
        </h1>
        <p>
            Закруглять углы элементов можно с помощью свойства border-radius.
            <br><br>
            Свойство задаёт радиус скругления углов в пикселях или процентах. Если у блока есть рамка, то скругляется и она.
        </p>
        <div class="image"><img src="image/border-radius1.jpg" alt=""></div>
        <p>
            Свойство border-radius принимает от одного до четырёх аргументов.
        </p>
        <div class="image"><img src="image/border-radius2.jpg" alt=""></div>
        <p>
            Вы можете закруглять отдельные углы с помощью свойств: border-top-left-radius,border-top-right-radius,
            border-bottom-right-radius и border-bottom-left-radius.
            <br><br>
            А ещё можно задавать разные горизонтальные и вертикальные радиусы скругления. Для этого нужно написать
            два значения через пробел в свойстве скругления угла. Первое значение задаёт радиус по горизонтали, второе — по вертикали:
        </p>
        <div class="image"><img src="image/border-radius3.jpg" alt=""></div>
        <pre>
            <code class="css">
                /* горизонтальный радиус 30px, вертикальный 15px */
                border-top-right-radius: 30px 15px;
            </code>
        </pre>
        <p>
            Разные горизонтальные и вертикальные радиусы можно задавать и в свойстве border-radius. Для этого нужно использовать /, например:
        </p>
        <pre>
            <code class="css">
                /* горизонтальный радиус всех углов 10px, вертикальный 5px */
                border-radius: 10px / 5px;

                /* разные горизонтальные и вертикальные радиусы у каждого угла */
                border-radius: 10px 20px 30px 40px / 5px 15px 25px 35px;
            </code>
        </pre>
    </div>

    <div class="row">
        <h1>
            Изображение рамки: border-image-source
        </h1>
        <p>
            Cемейство свойств border-image задаёт фоновое изображение для рамки блока. Поддержка данного семейства
            свойств в современных браузерах довольно неплохая.
            <br><br>
            Свойство border-image-source задаёт путь к изображению рамки. По умолчанию картинкой заполнятся только углы
            рамки. В следующих заданиях мы разберём, как можно управлять отображением рамки.
            <br><br>
            Синтаксис свойства такой же, как у background-image, то есть:
        </p>
        <pre>
            <code class="css">
                border-image-source: url("image.jpg");
            </code>
        </pre>

        <h1>
            Изображение рамки: border-image-slice
        </h1>

        <p>
            Давайте разберёмся, как работает механизм «нарезки» фонового изображения для рамки.
        </p>
        <div class="image"><img src="image/border-image-slice.jpg" alt=""></div>
        <p>
            Каждая рамка имеет 9 областей: 4 угла,4 стороны и центральную область. Для заполнения этих областей браузер
            должен нарезать картинку для рамки на 9 частей. Когда браузер не знает, как это сделать, он просто размещает
            картинку по углам — мы видели это в предыдущем задании.
            <br><br>
            Свойство border-image-slice задаёт отступы от краёв картинки до четырёх линий, которые «разрезают» её на
            части, как на схеме справа. Если эти отступы небольшие, то получается «нарезка» из 9частей, которые затем
            размещаются в соответствующих областях рамки.
            <br><br>
            Но если отступы слишком большие (больше половины картинки), то браузер не может получить 9 частей и
            располагает то, что отрезалось по углам.
            <br><br>
            Значение свойства можно задавать числом без единицы измерения (оно обычно обозначает пиксели) или в процентах
            (относительно размера самой картинки). Пример:
        </p>
        <pre>
            <code class="css">
                border-image-slice: 60;
                border-image-slice: 10%;
            </code>
        </pre>

        <h1>
            Нарезка несимметричных картинок
        </h1>
        <p>
            Сравните две картинки:
        </p>
        <div class="image"><img src="image/border-image-slice2.jpg" alt=""></div>
        <p>
            Для нарезки первой из них можно было задать одинаковые отступы линий разреза — 50px. Для второй картинки
            этого явно недостаточно — она менее симметрична.
            <br><br>
            С помощью border-image-slice можно задавать разные отступы линий разреза. Для этого нужно задавать значения
            через пробел в порядке: верх, право, низ, лево. Пример:
        </p>
        <pre>
            <code class="css">
                border-image-slice: 10 20 30 40;
            </code>
        </pre>
        <p>
            Средняя часть картинки обычно не используется. Но если в значение свойства добавить ключевое слово fill,
            то средняя часть картинки будет отображаться в средней области рамки: она закроет собой фон блока, но не
            закроет содержимое. Пример:
        </p>
        <pre>
            <code class="css">
                border-image-slice: 10 20 30 40 fill;
            </code>
        </pre>

        <h1>
            Изображение рамки: border-image-repeat
        </h1>
        <div class="image"><img src="image/border-image-slice3.jpg" alt=""></div>
        <p>
            Свойство border-image-repeat задаёт способ заполнения фоном боковых сторон рамки (зелёные области на рисунке).
            <br><br>
            У свойства четыре значения: stretch, repeat, space иround.
            <br><br>
            Значение по умолчанию — stretch. При этом значении фоновые картинки растягиваются на всю длину боковых сторон.
            <br><br>
            Если задано значение repeat, то фоновые картинки будут повторяться. При этом они могут обрезаться.
            <br><br>
            Можно устанавливать режим заполнения отдельно для горизонтальных и вертикальных сторон рамки.
            Например:
        </p>
        <pre>
            <code class="css">
                /* все стороны рамки заполняются в режиме stretch */
                border-image-repeat: stretch;

                /* горизонтальные стороны — режим repeat, вертикальные — stretch */
                border-image-repeat: repeat stretch;
            </code>
        </pre>
        <p>
            Значение round свойства border-image-repeat тоже устанавливает режим заполнения стороны рамки повторяющимися
            боковыми участками картинки. Но, в отличие от repeat, если в ширину стороны не вмещается целое число повторящихся
            кусочков, крайние части не обрезаются. Кусочки при этом равномерно растягиваются так, чтобы все они стали
            одного размера и заняли оставшееся место стороны рамки.
            <br><br>
            Согласно спецификации при заданном значении space алгоритм похож на round, только для компенсации оставшегося
            места кусочки картинки не растягиваются, а остаются прежней ширины, при этом между кусочками появляется
            дополнительное свободное пространство.
        </p>

        <h1>
            border-image-width
        </h1>
        <p>
            Следующее свойство, которое мы рассмотрим — border-image-width.
            <br><br>
            У блока должна существовать рамка определённой толщины border-width, тогда ему можно задать и фоновую
            картинку для рамки. Область, в которой будет отображаться эта картинка по умолчанию равна ширине рамки.
            <br><br>
            Свойство border-image-width позволяет управлять шириной видимой области рамки-картинки, масштабировать её.
            Саму ширину рамки это свойство не меняет.
            <br><br>
            Если значение этого свойства больше border-width, картинка рамки заползёт под содержимое, даже если не задано свойство fill.
            <br><br>
            Ширина рамки-картинки задаётся в %, px, em или других единицах измерения. Также возможно значение auto,
            при котором ширина зависит от значения border-image-slice.
            <br><br>
            Можно задавать разную ширину сторон. В этом случае значения перечисляются аналогичноmargin, padding в
            последовательности: верхнее, правое, нижнее, левое. Например:
        </p>
        <pre>
            <code class="css">
                border-image-width: 10px 20px 30px 40px;
                border-image-width: 10px 50px;
            </code>
        </pre>

        <h1>
            border-image-outset
        </h1>
        <p>
            Ещё одно свойство, относящееся к фоновому изображению рамки, border-image-outset. Аналогично outline-offset
            это свойство позволяет отодвинуть рамку за пределы элемента, но при этом одновременно немного масштабируя
            картинку. Отрицательные значенияborder-image-outset не поддерживаются.
            <br><br>
            К сожалению, свойство border-radius не влияет на border-image, так что единственный способ сделать округлую
            рамку — использовать круглую картинку.
            <br><br>
            Отступы рамок-изображений тоже можно задавать разные для каждой из сторон. Синтаксис обычный:
        </p>
        <pre>
            <code class="css">
                border-image-outset: 10px;
                border-image-outset: 10px 20px 30px 40px;
            </code>
        </pre>

        <h1>
            Рамки и треугольники
        </h1>
        <p>
            У рамок есть одна особенность: если рамка элемента широкая, а сам элемент имеет нулевую ширину и высоту, то стороны рамки становятся треугольными.
            <br><br>
            Чтобы сделать треугольник нужно:
        </p>
        <ul>
            <li>одной стороне рамки задать нулевую ширину,</li>
            <li>ещё две стороны сделать прозрачными,</li>
            <li>последней стороне задать нужный цвет.</li>
        </ul>
        <p>
            Похожим способом можно создавать треугольные стрелки, направленные по диагонали.
            Для этого:
        </p>
        <ul>
            <li>одной стороне рамки задаём нужный цвет,</li>
            <li>ещё двум сторонам задаём нулевую ширину,</li>
            <li>последнюю сторону делаем прозрачной.</li>
        </ul>
        <p>
            А теперь давайте добавим стрелке «хвост».
            <br><br>
            Принцип построения такой же, как и раньше, но теперь треугольником будет не сам элемент, а его псевдоэлемент.
            Сам же элемент будет «хвостом» стрелки.
        </p>
        <pre>
            <code class="css">
                .arrow-right-long {
                        position: relative;
                        margin: 150px auto;
                        width: 200px;
                        height: 30px;
                        background: #0074d9;
                }

                .arrow-right-long::after {
                        position: absolute;
                        top: -25px;
                        right: -30px;
                        content: '';
                        border:40px solid #fff;
                        border-width:40px 0 40px 40px;
                        border-color: transparent #fff transparent #0074d9;
                }
            </code>
        </pre>
        <p>
            Следующим шагом давайте применим изученный приём к круглому блоку.
            <br><br>
            В результате получится стрелка со скруглённым «хвостом».
        </p>
        <pre>
            <code class="css">
                .arrow-round {
                        position: relative;
                        margin: 100px auto;
                        width: 200px;
                        height: 200px;
                        border: 50px solid #0074d9;
                        border-radius: 50%;
                        border-color: #0074d9 transparent #0074d9 #0074d9;
                }

                /* Теперь займёмся самим указателем. Сделаем его по аналогии с прошлыми заданиями.  */
                .arrow-round::after {
                        position: absolute;
                        content: '';
                        top:-45px;
                        left:130px;
                        border:100px solid #fff;
                        border-color: #fff #fff #0074d9 transparent;
                        border-width: 0 0 100px 100px;
                }
            </code>
        </pre>

        <h1>
            Треугольники в жизни
        </h1>
        <p>
            А сейчас давайте посмотрим, как изученные ранее треугольники используются в реальных задачах.
            <br><br>
            Самый очевидный пример — иконки сортировки в каталогах товаров: треугольники, направленные вверх и вниз.
            <br><br>
            Почему их выгодно делать с помощью рамок? Потому что CSS-стрелкам можно легко менять пропорции, задавать
            разные цвета и размеры, а это очень гибко.
            <br><br>
            Обычно управляющие элементы для сортировки размечают с помощью ссылок. Мы поступим так же: внутри ссылки
            будет поясняющий текст, а в стрелку превратим псевдоэлемент ссылки.
        </p>
        <pre>
            <code class="css">
                .arrow::before {
                        content: '';
                        border: 20px solid #0074D9;
                        border-right-width: 10px;
                        border-left-width: 10px;
                        border-right-color: transparent;
                        border-left-color: transparent;
                }
            </code>
        </pre>
        <p>
            Теперь добавим дополнительные классы arrow-up и arrow-down, которые будут обозначать направление стрелки вверх и вниз.
            <br><br>
            Для стрелки вверх нужно будет убрать нижнюю рамку у псевдоэлемента, а у стрелки вниз — верхнюю рамку.
            Чтобы стрелки вели себя в потоке, как текст, зададим псевдоэлементам блочно-строчный тип.
            <br><br>
            И последним шагом скроем текст подписи у ссылки, для этого просто зададим нулевой размер шрифта.
            <br><br>
            Есть и более сложный вариант стрелок для сортировки: когда у каждого параметра создаются сразу две стрелки.
            Этот вариант делается схожим образом, но для создания стрелок используются оба псевдоэлемента: и ::before, и ::after.
            <br><br>
        </p>
        <ul>
            <li>Для .arrow-down::before обнулите толщину нижней рамки,</li>
            <li>затем для .arrow-up::before обнулите толщину верхней рамки.</li>
            <li>Для .arrow::before задайте свойство display: inline-block,</li>
            <li>а затем самим ссылкам .arrow обнулите размер шрифта.</li>
        </ul>
    </div>
</div>

<?php include ("footer.php") ?>